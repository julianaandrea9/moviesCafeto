"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const parseEndpoint_1 = __importDefault(require("./parseEndpoint"));
const normalizeQuery_1 = __importDefault(require("./normalizeQuery"));
const requests_1 = require("./requests");
const catchHTTPErrors_1 = __importDefault(require("./catchHTTPErrors"));
const DataController_1 = __importDefault(require("../DataController"));
const url_1 = require("url");
const createEndpoint = (type, endpoint) => {
    const data = DataController_1.default.getInstance();
    return async ({ body, pathParameters, query }) => {
        if (pathParameters) {
            endpoint = parseEndpoint_1.default(endpoint, pathParameters);
        }
        if (query) {
            if (query['api_key']) {
                delete query['api_key'];
            }
            if (query['language']) {
                delete query['language'];
            }
        }
        const readyQuery = new url_1.URLSearchParams({
            api_key: data.get('apiKey'),
            language: data.get('language'),
        });
        if (query) {
            normalizeQuery_1.default(query).forEach(entry => {
                readyQuery.append(entry[0], entry[1]);
            });
        }
        try {
            switch (type) {
                case 'GET': {
                    const response = await requests_1.request(endpoint, { query: readyQuery });
                    return {
                        data: response.body,
                        headers: response.headers,
                        rateLimit: {
                            limit: parseInt(response.headers['x-ratelimit-limit'], 10),
                            remaining: parseInt(response.headers['x-ratelimit-remaining'], 10),
                            reset: parseInt(response.headers['x-ratelimit-reset'], 10),
                        },
                    };
                }
                case 'POST': {
                    const response = await requests_1.request.post(endpoint, { query: readyQuery, body });
                    return {
                        data: response.body,
                        headers: response.headers,
                        rateLimit: {
                            limit: parseInt(response.headers['x-ratelimit-limit'], 10),
                            remaining: parseInt(response.headers['x-ratelimit-remaining'], 10),
                            reset: parseInt(response.headers['x-ratelimit-reset'], 10),
                        },
                    };
                }
                case 'DELETE': {
                    const response = await requests_1.request.delete(endpoint, { query: readyQuery, body });
                    return {
                        data: response.body,
                        headers: response.headers,
                        rateLimit: {
                            limit: parseInt(response.headers['x-ratelimit-limit'], 10),
                            remaining: parseInt(response.headers['x-ratelimit-remaining'], 10),
                            reset: parseInt(response.headers['x-ratelimit-reset'], 10),
                        },
                    };
                }
                default: break;
            }
        }
        catch (error) {
            catchHTTPErrors_1.default(error);
            throw error;
        }
    };
};
exports.default = (endpoints) => {
    const root = {};
    endpoints.forEach(endpoint => {
        root[endpoint.name] = createEndpoint(endpoint.type, endpoint.endpoint);
    });
    return root;
};
